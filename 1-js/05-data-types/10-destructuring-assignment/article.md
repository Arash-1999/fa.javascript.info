# تخصیص ساختارشکنانه

اشیا(ابجکت)و آرایه ها پرمصرفترین ساختار داده ها هستند.

اشیا به ما اجازه میدهند که یک موجودیت که داده را با یک کلید ذخیره میکند٬ و آرایه ها به ما اجازه میدهند که داده ها را در یک مجموعه شماره گذاری شده ذخیره کنیم.

اما زمانیکه ما آنها را به یک تابع میدهیم٬ ممکن است یک شی یا آرایه را بطور کامل نخواهد٬ بلکه قسمت های جداگانه ای را بخواهد.

تخصیص ساختارشکنانه یک نوشتار خاص است که به ما اجازه میدهد آرایه ها یا اشیا را به تعدادی متغیر تبدیل کنیم٬ که گاهی اوقات کار کردن با آنها راحتتر شود. همچنین ساختارشکنی با توابع پیچیده که تعداد زیادی پارامتر٬ مقادیر پیشفرض و ... دارند.

## ساختار شکنی آرایه

یک مثال از چگونگی ساختار شکنی آرایه ها:‌

```js
// یک آرایه شامل اسم و فامیل داریم
let arr = ["Ilya", "Kantor"];

*!*
// تخصیص ساختارشکنانه
// متغیر اول را به عضو اول آرایه اختصاص میدهد
// و دومی را به دومی
let [firstName, surname] = arr;
*/!*

alert(firstName); // Ilya
alert(surname); // Kantor
```

حال میتوانی به جای کار کردن با آرایه از متغیرها استفاده کنیم.

خیلی بهتر میشود که این را با `split` یا متد هایی که ارایه باز میگردانند ترکیب کنیم.

```js
let [firstName, surname] = "Ilya Kantor".split(' ');
```

````smart header = "ساختارشکنی به معنای تخریب نیست"
به این تخصیص ساختارشکنانه میگویند٬ زیرا این ساختار را کپی کردن ایتم آیتم در متغیرها میشکند. ولی خود آرایه دست نخورده باقی میماند.

این فقط یک راه کوتاه تر برای نوشتن است.
```js
//let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
```
````

````smart header = "چشم پوشی از المان ها با ویرگول"
از المان هایی که نمیخواهیم میتوان با یک ویرگول اضافه چشمپوشی کرد.

```js run
*!*
// نیازی به المان دوم نیست
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
*/!*

alert(title); //Consul
```
```
در قطعه کد بالا٬‌ از المان دوم آرایه چشمپوشی شده و سومی به `title` اختصاص داده شده است. همچنین از بقیه آیتم ها چشمپوشی شده است چون متغیری برای آنها وجود ندارد.
````

````smart header = "کار کردن با هر چیز پیمودنی در سمت راست"

```در واقع ما میتوانیم از هر چیز پیمودنی دیگر استفاده کنیم. نه فقط آرایه ها.

```js run
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

````


````smart header = "اختصاص دادن به هر چیزی در سمت چپ"

ما میتوانیم از هر چیز اختصاص دادنی در سمت چپ استفاده کنیم.

برای مثال یک ویژگی از شی:
```js run
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
```

````

````smart header = "چرخیدن با entries()"

در بخش قبل دیدیم که از متد [Object.entries(obj)](mdn:js/Object/entries) استفاده کردیم.

میتوانیم از ساختارشکنی برای چرخیدن روی کلید-و-مقدار های اشیا استفاده کنیم.

```js run
let user = {
    name: "john",
    age: 30
};

// چرخیدن روی کلیدها و مقدارها
*!*
for(let [key, value] of Object.entries(user)){
    */!*
    alert(`${key}: ${value}`); // name:John, then age: 30
}
```

``` و بطور مشابه برای پیمودن:

```js run
let user = new Map();
user.set("name", "John");
user.set("age", "30");

*!*
for(let [key, value] of user) {
*/!*
    alert(`${key}: ${value}`); // name: John, then age: 30
}
```
````

```smart header = ""
یک ترفند خوب برای جابجا کردن مقادیر دو متغیر:‌

```js run
let guest = "Jane";
let admin = "Pete";

// جابجا کردن مقدارها : guest = Pete, admin= Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)
```

در اینجا ما یک آرایه موقتی از دو متغیرمان ساختیم و سریعا آن را به دو متغیر با ترتیب جابجا شکستیم.

میتوانیم بیش از دو متغیر را به این روش جابجا کنیم.


### باقی ...

اگر بخواهیم فقط مقادیر اولیه را بگیریم٬ ولی بخواهیم همه مقادیر بعدی را بگیریم میتوانیم یک پارامتر٬ دیگر به نام باقی با استفاده از سه تا نقطه `"..."` اضافه کرد.

```js run
let [name1, name2, *!*...rest*/!*] = ["Julius", "Caesar", *!*"Consul", "of the Roman Republic"*/!*];

alert(name1); // Julius
alert(name2); // Caesar

*!*
//
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
*/!*
```

مقدار `rest` یک آرایه از المان های باقیمانده است. میتوانیم هر نام دیگری برای متغیر `rest` استفاده کنیم٬ فقط مطمعن شوید که سه نقطه قبل از آن گذاشته اید و آخرین چیز در تخصیص ساختارشکنانه است.

### مقادیر پیشفرض

اگر تعداد مقادیر از تعداد متغیر های آرایه کمتر باشد خطایی ظاهر نمیشود. مقادیر غایب تعریف نشده فرض میشوند(undefined).

```js run
*!*
let [firstName, surname] = [];
*/!*

alert(firstName); // undefined
alert(surname); // undefined
```

اگر بخواهیم یک مقدار پیشفرض تعریف کنیم میتوانیم با عملگر `=` آن را تعریف کنیم:

```js run
*!*
// مقادیر پیشفرض
let [name = "Guest", surname = "Anonymous"] = ["Julius"];
*/!*

alert(name); // Julius (from array)
alert(surname); // Anonymous (default used)
```

مقادیر پیشفرض میتوانند محاسبات پیچیده تر و هم چنین توابع باشند. آنها فقط زمانیکه مقداری وجود نداشته باشند محاسبه میشوند.

برای مثال٬ اینجا از تابع `prompt` برای مقدار پیشفرض استفاده میکنیم. اما این تابع فقط زمانیکه که مقداری وجود نداشته باشد اجرا میشود.

```js
// تابع `propmt` را فقط برای فامیل اجرا میکند
let [name = prompt("name?"), surname = prompt("surname?")] = ["Julius"];

alert(name); // Julius (from array)
alert(surname); // Whatever prompt gets
```



## ساختارشکنی اشیا

تخصیص ساختارشکنانه همچنین روی اشیا نیز کار میکند.

نوشتار ساده آن به صورت زیر است.

```js
let {var1, var2} = {var1: ..., var2: ...};
```

یک شی تعریف شده در سمت راست داریم٬ که میخواهیم آن را متغیرها بشکنیم. سمت چپ یک شامل یک الگو برای ویژگی های تعریف شده است. در حالت ساده یک لیست از اسامی متغیرها بصورت `{...}` است.

برای مثال:

```js
let options = {
    title: "Menu",
    width: 100,
    height: 200
};

*!*
let {title, width, height} = options;
*/!*

alert(title); // Menu
alert(width); // 100
alert(height); // 200
```

ویژگی های `options.title`٬ `options.width` و `options.height` به متغیرهای مساویشان اختصاص داده شدند. ترتیب مهم نیست. همچنین این نیز کار میکند.

```js
// عوض کردن ترتیب در تعریف
let {height, width, title} = {title: "Menu", height: 200, width: 100};
```

الگوی سمت راست میتواند پیچیده تر باشد مثلا پیمایش بین ویژگی ها و متغیر ها باشد.

اگر بخواهیم ویژگیی را به متغیری با نام دیگیری اختصاص دهیم٬ مثلا `options.width` را به متغیری به نام `w` بدهیم٬ این کار با یک کولن(:) میتوانیم انجام دهیم.

```js
let options = {
    title: "Menu",
    width: 100,
    height: 200
};

*!*
// { sourceProperty: targetValue}
let { width: 2, height: h, title} = options;
*/!*

// width -> w
// height -> h
// title -> title

alert(title); // Menu
alert(w); // 100
alert(h); // 200
```

کولن نشان میدهد "چه چیزی:‌ کجا برود". در مثال بالا ویژگی `width` به `w` ٬ ویژگی `height` به `h` و ویژگی `title` به نامه مشابهش اختصاص داده شد.

به خاطر ممکن بودن وجود نداشتن ویژگی میتوانیم مقدار پیشفرض را با `=` تعریف کنیم. بصورت زیر:

```js
let options = {
    title: "Menu"
};

*!*
let { wdith = 100, height = 200, title} = options;
*/!*

alert(title); // Menu
alert(width); // 100
alert(height); // 200
```

مانند آرایه ها و پارامتر های توابع٬‌ مقادیر پیشفرض میتوانند هر محاسبه یا فراخوانی تابعی باشند. آنها فقط زمانی اجرا میشوند که مقداری وجود نداشته باشد.

در کد پایین `prompt` برای `width` سوال میپرسد ولی برای `title` نه:

```js
let options = {
    title: "Menu"
};

*!*
let { wdith = prompt("width?"), title = prompt("title?")} = options;
*/!*

alert(title); // Menu
alert(width); // (Whatever the result of prompt is)
```

هم چنین میتوانیم کولن و مساوری را با هم  ترکیب کنیم.

```js
let options = {
    title: "Menu"
};

*!*
let {width: w = 100, height: h = 200, title} = options;
*/!*

alert(title); // Menu
alert(w); // 100
alert(h); // 200
```

اگر یک شی پیچیده با چندین ویژگی داشته باشیم میتوانیم فقط آنهایی که نیاز داریم را استخراج کنیم.

```js
let options = {
    title: "Menu",
    width: 100,
    height: 200
};

// فقط تیتر را به عنوان متغیر اسختراج میکند
let {title} = options;

alert(title); // Menu
```

## الگوی باقی "..."

اگر شی مان بیشتر از متغیرهایی که داریم ویژگی داشته باشد چی؟‌ آیا میتوانیم برخی از آنها را بگیریم و بقیه را به یک جای دیگر اختصاص دهیم؟

میتوانیم از الگوی باقی استفاده کنیم٬ همانطور که در آرایه ها استفاده کردیم. در برخی مرورگر ها پشتیبانی نمیشو ولی در نسخه های جدید کاملا کار میکند.

که به این صورت است:‌

```js
let options = {
    title: "Menu",
    height: 200,
    width: 100
};

*!*
// title = ویژگی با نام مشابه
// rest = یک شی با باقی ویژگی های مانده
let {title, ...rest} = options;
*/!*

// الان title="Menu", rest={height: 200, width: 100}
alert(rest.height); // 200
alert(rest.width); // 100
```

````smart header = "اکر `let` نباشد چه میشود"
اگر از `let` نداشته باشیم چی؟ در مثال بالا همان جا که میخواستیم به متغیرها مقدار اختصاص دهیم تعریفشان نیز کردیم. `let {...} = {...}`.حتما٬ ما میتوانیم متغیر های تعریف شده را نیز استفاده کنیم. ولی یک نکته وجود دارد.

این کار نمیکند:
```js
let title, width, height;

// خطا در این خط رخ میدهد
{title, width, height} = {title: "Menu", width: 200, height: 100};
```

مشکل اینجاست که جاوااسکریپت با `{...}` در جریان اصلی کد(در یک عبارت دیگر) مانند یک یک بلوک مد رفتار میکند.  برخی بلوک کدها میتوانند در گروهی از جملات استفاده شوند٬ مانند این:

```js
{
    // یک بلوک کد
    let message = "Hello";
    // ...
    alert( message );
}
```

اینجا جاوااسکریپت فرض میکند که یک بلوک کد داریم٬ این دلیل خطای رخ داده است. حال ما میخواهیم به جای آن ساختارشکنی کنیم.

برای اینکه به جاوااسکریپت نشان دهیم این یک بلوک کد نیست٬ میتوانیم عبارتمان را در `(..._)` قرار دهیم.

```js
let title, wdith, height;

// حال درست کار میکند
*!*(*/!*{title, width, height} = {title: "Menu", width: 200, height: 100}*!*)*/!*;

alert(title); // Menu
```
````

## ساختارشکنی های تودرتو

اگر یک شی یا یک آرایه شامل اشیا یا آرایه های دیگری باشد٬ میتوانیم از الگوهای پیچیده تری در سمت چپ استفاده کنیم تا قسمت های عمیق تر را استخراج کنیم.

در کد زیر `options` در ویژگی هایش یک شی دیگر دارد به نام `size` و یک آرایه در ویژگی `items`. الگوی استفاده شده در سمت چپ تخصیص ساختار مشابهی برای استخراج مقادیر دارد:

```js run
let options = {
    size: {
        wdith: 200,
        hieght: 100
    },
    items: ["Cake", "Donut"],
    extra: true
};

// ساختارشکنی را در چند خط نوشتیم برای وضوح بیشتر
let {
    size: { // اندازه را در اینجا قرار میدهیم
        width,
        height
    },
    items: [item1, item2], // آیتم ها را اینجا مشخص میکنیم
    title = "Menu" // در شیمان وجود ندارد پس از مقدار پیشفرض استفاده میکند
} = options;

alert(title); // Menu
alert(width); // 100
alert(height); // 200
alert(item1); // Cake
alert(item2); // Donut
```

تمام ویژگی های `options` به جز `extra` که در سمت چپ موجود نیست به متغیر مربوطه اختصاص داده شده اند.

![](destructurin-complex.svg)

در آخر٬ `width`, `height`, `item1`, `item2`, `title` را از مقادیر پیشفرض داریم.

دقت کنید که هیچ متغیری برای `size` و `items` وجود ندارد. فقط محتوای آنها را گرفتیم.

### پارامتر های هوشمندانه توابع

گاهی اوقات توابعی هستند که چندین پارامتر میگیرند که اکثرا اختیاری هستند.که مخصوصا برای رابط کاربری هستند.تابعی را تصور کنید که یک منو میسازد. میتواند طول٬ عرض٬ تیتر٬ آیتم های لیست و ... باشد.

این یک راه بد برای نوشتن چنین تابعی است: 

```js
function showMenu(title = "undefined", width = 200, height = 100, items = []) {
    // ...
};
```

در عمل مشکل به یاد اوردن ترتیب پارامتر هاست. معمولا محیط برنامه نویسی تلاش میکنند به ما کمک کنند. مخصوصا زمانی که کد به خوبی نوشته شده باشد٬ ولی ... .مشکل دیگر این است چگونه تابعی که بیشتر پارامترهایش بطور پیشفرض درست هستند را صدا بزنیم.

این شکلی ؟

```js
//
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"]);
```

این زشت است. و اگر پارامترها بیشتر شود ناخوانا میشود.

ساختارشکنی برای نجات ما می آید.

میتوانیم پارامترها را به صورت یک شی بدهیم و تابع به سرعت آن را به متغیرهای مختلف میشکند.

```js run
// شی را به تابه میدهیم
let options = {
    title: "My Menu",
    items: ["Item1", "Item2"]
};

// ...این به سرعت آنها را به متغیرهای مختلف باز میکند
function showMenu(*!*{title = "undefined", width = 200, height = 100, items = []}*/!*) {
    // تیتر و آیتمها از شی گرفته میشوند
    // طول و عرض از مقادیر پیشفرض استفده میکنند
    alert( `${title} ${width} ${hieght}` ); // My Menu 200 100
    alert( items ); / Item1, Item2
}

showMenu(options);
```

هم چنین میتوانیم از ساختارشکنی های پیجیده تر با اشیا تودرتو و پیمایش با کولن استفاده کنیم:

```js run
let opitons = {
    title: "My Menu",
    items: ["Item1", "Item2"]
};

*!*
function showMneu({
    title = "undefined",
    width: w = 100, // طول به w میرود
    height: h = 200, // عرض به h میرود
    items: [item1, item2] // در آیتمها اولی به item1و دومی به item2 میرود
}) {
*/!*
    alert(`${title} ${w} ${h}); // My Menu 100 200
    alert(item1); // Item1
    alert(item2); // Item2
};

showMenu(options);
```

نوشتار کامل مشابه تخصیص ساختارشکنانه در قبل است.
```js
function({
    incomingProperty: varName = defaultValue
    ...
})
```

سپس٬ برای یک شی از پارامترها٬ یک متغیر به نام `varName` برای ویژگی `incomingProperty`٬ با مقدار `defaultValue` برای مقدار پیشفرض تعریف میکند.

لطفا به یاد داشته باشید که در این روش تابع یک اشیا به عنوان پارامتر میخواهد. اگر بخواهیم همه مقادیر به صورت پیشفرض تعریف شوند باید ک شی خالی به تابع بدهیم.

```js
showMenu({}); // درست است. تمام مقدار ها پیشفرض هستند

showMenu(); // خطا رخ میدهد
```

میتوانیم این مشکل را با درست کردن یک مقدار پیشفرض به صورت `{}` برای کل پارامتر حل کنیم.

```js run
function showMenu({title = "Menu", width = 100, height = 200, }*!* = {} */!*) {
    alert(`${title} ${width} ${height}`);
}

showMenu(); // Menu 100 200
```

در کد بالا٬ کل آرگومان تابع یک شی خالی است پس همیشه یک شی برای ساختارشکنی وجود دارد.

## خلاصه

- ساختارشکنی به ما اجازه میدهد که سریعا اشیا و آرایه ها را به چند متغیر بشکنیم.
- نوشتار کلی برای اشیا به صورت زیر است:
    ```js 
    let { prop: varName = default, ...rest} = object;
    ```

    این یعنی ویژگی `prop` باید به متغیر `varName` برود و اگر مقداری برای آن وجود نداشت آنگاه مقدار `default` باید استفاده شود.

    ویژگی های شیمان که به متغیری اختصاص داده نشده اند در شیی به نام `rest` کپی میشوند.

- نوشتار کلی برای آرایه ها بصورت زیر است:

    ```js
    let [item1 = default, item2, ...rest] = array;
    ```

    آیتم اول به `item1` میرود دومی به `item2` میرود و باقی مقادیر به آرایه به نام `rest` میروند.

- این امکانپذیر است که داده ها را از اشیا یا آرایه های تودرتو استخراج کرد.برای اینکار باید در سمت چپ ساختاری دقیقا مشابه سمت چپ داشته باشیم.